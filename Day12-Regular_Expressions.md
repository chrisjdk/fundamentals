[TOC]

## 使用正则表达式

### Background Knowledge

在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式. 今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。

关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫[《正则表达式30分钟入门教程》](https://deerchao.net/tutorials/regex/regex.htm)

### Notes of 《正则表达式30分钟入门教程》

用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用`\bhi\b`。

`\b`是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是`\b`并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。如果需要更精确的说法，`\b`匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)`\w`。

假如你要找的是hi后面不远处跟着一个Lucy，你应该用`\bhi\b.*\bLucy\b`。

`0\d\d-\d\d\d\d\d\d\d\d`匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字,这里的`\d`是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。
为了避免那么多烦人的重复，我们也可以这样写这个表达式：`0\d{2}-\d{8}`。这里`\d`后面的`{2}`(`{8}`)的意思是前面\d必须连续重复匹配2次(8次)。

#### 元字符

`\s`匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。`\w`匹配字母或数字或下划线或汉字等。

下面来看看更多的例子：

`\ba\w*\b`匹配以字母a开头的单词——先是某个单词开始处(`\b`)，然后是字母a,然后是任意数量的字母或数字(`\w*`)，最后是单词结束处(`\b`)。

`\d+`匹配1个或更多连续的数字。_这里的`+`是和`*`类似的元字符，不同的是`*`匹配重复任意次(可能是0次)，而`+`则匹配重复1次或更多次_。

`\b\w{6}\b` 匹配刚好6个字符的单词。

元字符`^`和`$`都匹配一个位置，这和`\b`有点类似。`^`匹配你要用来查找的字符串的开头，`$`匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：`^\d{5,12}$`。
这里的`{5,12}``和前面介绍过的`{2}`是类似的，只不过``{2}`匹配只能不多不少重复2次，`{5,12}`则是重复的次数不能少于5次，不能多于12次，否则都不匹配。有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，`^`和`$`的意义就变成了匹配行的开始处和结束处。

如果不使用`^`和`$`的话，对于`\d{5,12}`而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。

下面的表格是对正则表达式中的一些基本符号进行的扼要总结。



| Symbol        | Expanation                       | Example          | Information                                                  |
| ------------- | -------------------------------- | ---------------- | ------------------------------------------------------------ |
| .             | 匹配任意字符                     | b.t              | 可以匹配bat / but / b#t / b1t等                              |
| \w            | 匹配字母/数字/下划线             | b\wt             | 可以匹配bat / b1t / b_t等但不能匹配b#t                       |
| \s            | 匹配空白字符（包括\r、\n、\t等） | love\syou        | 可以匹配love you                                             |
| \d            | 匹配数字                         | \d\d             | 可以匹配01 / 23 / 99等                                       |
| \b            | 匹配单词的边界                   | \bThe\b          | .                                                            |
| ^             | 匹配字符串的开始                 | ^The             | 可以匹配The开头的字符串                                      |
| $             | 匹配字符串的结束                 | .exe$            | 可以匹配.exe结尾的字符串                                     |
| \W            | 匹配非字母/数字/下划线           | b\Wt             | 可以匹配b#t / b@t等,但不能匹配but / b1t / b_t等              |
| \S            | 匹配非空白字符                   | love\Syou        | 可以匹配love#you等,但不能匹配love you                        |
| \D            | 匹配非数字                       | \d\D             | 可以匹配9a / 3# / 0F等                                       |
| \B            | 匹配非单词边界                   | \Bio\B           |                                                              |
| \[\]          | 匹配来自字符集的任意单一字符     | \[aeiou\]        | 可以匹配任一元音字母字符                                     |
| \[^]          | 匹配不在字符集中的任意单一字符   | \[^aeiou\]       | 可以匹配任一非元音字母字符                                   |
| *             | 匹配0次或多次                    | \w*              |                                                              |
| +             | 匹配1次或多次                    | \w+              |                                                              |
| ?             | 匹配0次或1次                     | \w?              |                                                              |
| {N}           | 匹配N次                          | \w{3}            |                                                              |
| {M,N}         | 匹配至少M次至多N次               | \w{3,6}          |                                                              |
| \|            | 分支                             | foo\|bar         | 可以匹配foo或者bar                                           |
| (?#)          | 注释                             |                  |                                                              |
| (exp)         | 匹配exp并捕获到自动命名的组中    |                  |                                                              |
| (? <name>exp) | 匹配exp并捕获到名为name的组中    |                  |                                                              |
| (?:exp)       | 匹配exp但是不捕获匹配的文本      |                  |                                                              |
| (?=exp)       | 匹配exp前面的位置                | \b\w+(?=ing)     | 可以匹配I'm dancing中的danc                                  |
| (?<=exp)      | 匹配exp后面的位置                | (?<=\bdanc)\w+\b | 可以匹配I love dancing and reading中的第一个ing              |
| (?<!exp)      | 匹配前面不是exp的位置            |                  |                                                              |
| *?            | 重复任意次，但尽可能少重复       | a.*b<br/>a.*?b   | 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 |
| +?            | 重复1次或多次，但尽可能少重复    |                  |                                                              |
| ??            | 重复0次或1次，但尽可能少重复     |                  |                                                              |
| {M,N}?        | 重复M到N次，但尽可能少重复       |                  |                                                              |
| {M,}?         | 重复M次以上，但尽可能少重复      |                  |                                                              |



#### 字符转义

如果你想查找元字符本身的话，这时你就得使用`\`来取消这些字符的特殊意义。因此，你应该使用`\.`和`\*`。当然，要查找`\`本身，你也得用`\\`.

#### 重复

下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：


| Codes/Grammer | Expanation       |
| ------------- | ---------------- |
| *             | 重复零次或更多次 |
| +             | 重复一次或更多次 |
| ?             | 重复零次或一次   |
| {n}           | 重复n次          |
| {n,}          | 重复n次或更多次  |
| {n,m}         | 重复n到m次       |

下面是一些使用重复的例子：

`Windows\d+`匹配Windows后面跟1个或更多数字
`^\w+`匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)

#### 字符类

  想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),只需要在方括号里列出它们就行了，像`[aeiou]`就匹配任何一个英文元音字母，`[.?!]`匹配标点符号(.或?或!)。

  下面是一个更复杂的表达式：`\(?0\d{2}[) -]?\d{8}`。(“(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。)

  这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。

#### 分枝条件

  正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用`|`把不同的规则分隔开。A relevant example to demonstrate this point:

  The above expression will generate some wrong results such as: 010)12345678 or (010-1234567. Now we will rewrite the above expression to generate our desired phone number.

  `0\d{2}-\d{8}|0\d{3}-\d{7}`: 这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。

  `\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}`这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。

  `\d{5}-\d{4}|\d{5}`这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成`\d{5}|\d{5}-\d{4}`的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。

#### 分组

  你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了.

  `(\d{1,3}\.){3}\d{1,3}`是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，`(\d{1,3}\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(`\d{1,3}`)。

  不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`。

#### 反义

  有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：

| Codes/ Grammers | Expanations                                |
| --------------- | ------------------------------------------ |
| \W              | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S              | 匹配任意不是空白符的字符                   |
| \D              | 匹配任意非数字的字符                       |
| \B              | 匹配不是单词开头或结束的位置               |
| \[^x]           | 匹配除了x以外的任意字符                    |
| \[^aeiou]       | 匹配除了aeiou这几个字母以外的任意字符      |


例子：`\S+`匹配不包含空白符的字符串。
`<a[^>]+>`匹配用尖括号括起来的以a开头的字符串。

#### 后向引用

  使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

__分组规则__:

- 分组0对应整个正则表达式
  
- 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配.因此所有命名组的组号都大于未命名的组号
  
- 你可以使用`(?:exp)`这样的语法来剥夺一个分组对组号分配的参与权．

__后向引用__用于重复搜索前面某个分组匹配的文本。例如，`\1`代表分组1匹配的文本。See the example below:

`\b(\w+)\b\s+\1\b`可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字`(\b(\w+)\b)`，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符`(\s+)`，最后是分组1中捕获的内容（也就是前面匹配的那个单词）`(\1)`。

你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：`(?<Word>\w+)`(或者把尖括号换成`'`也行：`(?'Word'\w+))`,这样就把`\w+`的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用`\k<Word>`,所以上一个例子也可以写成这样：`\b(?<Word>\w+)\b\s+\k<Word>\b`。

使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：

| 分类     | 代码／语法     | 说明                                                         |
| -------- | -------------- | ------------------------------------------------------------ |
| **捕**   | `(exp)`        | 匹配exp,并捕获文本到自动命名的组里                           |
|          | `(?<name>exp)` | 匹配exp,并捕获文本到名称为name的组里，也可以写成`(?'name'exp)` |
| **获**   | `(?:exp)`      | 匹配exp,不捕获匹配的文本，也不给此分组分配组号               |
|          |                |                                                              |
| **零**   | `(?=exp)`      | 匹配exp前面的位置                                            |
| **宽**   | `(?<=exp)`     | 匹配exp后面的位置                                            |
| **断**   | `(?!exp)`      | 匹配后面跟的不是exp的位置                                    |
| **言**   | `(?<!exp)`     | 匹配前面不是exp的位置                                        |
|          |                |                                                              |
| **注释** | `(?#comment)`  | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |


我们已经讨论了前两种语法。第三个`(?:exp)`不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。至于作用，一般来说是为了节省资源，提高效率

#### 零宽断言

  接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像`\b`,`^`,`$`那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。

  `(?=exp)`也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如`\b\w+(?=ing\b)`，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。

  `(?<=exp)`也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如`(?<=\bre)\w+\b`会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。

  假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：`((?<=\d)\d{3})+\b`，用它对1234567890进行查找时结果是234567890。

下面这个例子同时使用了这两种断言：`(?<=\s)\d+(?=\s)`匹配以空白符间隔的数字(再次强调，不包括这些空白符)。                                                       

#### 负向零宽断言

前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：

  `\b\w*q[^u]\w*\b`匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为`[^u]`总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的`[^u]`将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的`\w*\b`将会匹配下一个单词，于是`\b\w*q[^u]\w*\b`就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：`\b\w*q(?!u)\w*\b`。

**零宽度负预测先行断言**`(?!exp)`，断言此位置的后面不能匹配表达式exp。例如：`\d{3}(?!\d)`匹配三位数字，而且这三位数字的后面不能是数字；`\b((?!abc)\w)+\b`匹配不包含连续字符串abc的单词。

同理，我们可以用`(?<!exp)`,**零宽度负回顾后发断言**来断言此位置的前面不能匹配表达式exp：`(?<![a-z])\d{7}`匹配前面不是小写字母的七位数字。

一个更复杂的例子：`(?<=<(\w+)>).*(?=<\/\1>)`匹配不包含属性的简单HTML标签内里的内容。`(?<=<(\w+)>)`指定了这样的**前缀**：被尖括号括起来的单词(比如可能是`<b>`)，然后是`.*`(任意的字符串),最后是一个**后缀**`(?=<\/\1>)`。注意后缀里的`\/`，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。

#### 注释

小括号的另一种用途是通过语法`(?#comment)`来包含注释。例如：`2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`。

要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：

```reStructuredText
(?<=    # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
)       # 后缀结束
```

#### 贪婪与懒惰

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：`a.*b`，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索*aabab*的话，它会匹配整个字符串aabab。这被称为**贪婪**匹配。

为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。

有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号`?`。这样`.*?`就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：

`a.*?b`匹配最短的，以a开始，以b结束的字符串。如果把它应用于*aabab*的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

| Codes/ Grammers | Expanations                     |
| --------------- | ------------------------------- |
| `*?`            | 重复任意次，但尽可能少重复      |
| `+?`            | 重复1次或更多次，但尽可能少重复 |
| `??`            | 重复0次或1次，但尽可能少重复    |
| `{n,m}?`        | 重复n到m次，但尽可能少重复      |
| `{n,}?`         | 重复n次以上，但尽可能少重复     |

#### 平衡组/递归匹配

有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用`\(.+\)`则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如*( 5 / ( 3 + 2 ) ) )*，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？

为了避免(和\(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把`xx <aa <bbb> <bbb> aa> yy`这样的字符串里，最长的配对的尖括号内的内容捕获出来？

这里需要用到以下的语法构造：

- `(?'group')`把捕获的内容命名为group,并压入**堆栈(Stack)**
- `(?'-group')`从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
- `(?(group)yes|no)`如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
- `(?!)`零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

我们需要做的是每碰到了左括号，就在压入一个"Open",每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。

```reStructuredText
<                         #最外层的左括号
    [^<>]*                #最外层的左括号后面的不是括号的内容
    (
        (
            (?'Open'<)    #碰到了左括号，在黑板上写一个"Open"
            [^<>]*       #匹配左括号后面的不是括号的内容
        )+
        (
            (?'-Open'>)   #碰到了右括号，擦掉一个"Open"
            [^<>]*        #匹配右括号后面不是括号的内容
        )+
    )*
    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的"Open"；如果还有，则匹配失败

>                         #最外层的右括号
```

平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的`<div>`标签：`<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>`.

#### 尚未详细讨论的语法

| Codes/ Grammers   | Expanations                                                  |
| ----------------- | ------------------------------------------------------------ |
| \a                | 报警字符(打印它的效果是电脑嘀一声)                           |
| \b                | 通常是单词分界位置，但如果在字符类里使用代表退格             |
| \t                | 制表符，Tab                                                  |
| \r                | 回车                                                         |
| \v                | 竖向制表符                                                   |
| \f                | 换页符                                                       |
| \n                | 换行符                                                       |
| \e                | Escape                                                       |
| \0nn              | ASCII代码中八进制代码为nn的字符                              |
| \xnn              | ASCII代码中十六进制代码为nn的字符                            |
| \unnnn            | Unicode代码中十六进制代码为nnnn的字符                        |
| \cN               | ASCII控制字符。比如\cC代表Ctrl+C                             |
| \A                | 字符串开头(类似^，但不受处理多行选项的影响)                  |
| \Z                | 字符串结尾或行尾(不受处理多行选项的影响)                     |
| \z                | 字符串结尾(类似$，但不受处理多行选项的影响)                  |
| \G                | 当前搜索的开头                                               |
| \p{name}          | Unicode中命名为name的字符类，例如\p{IsGreek}                 |
| (?>exp)           | 贪婪子表达式                                                 |
| `(?<x>-<y>exp)`   | 贪婪子表达式                                                 |
| `(?im-nsx:exp)`   | 在子表达式exp中改变处理选项                                  |
| `(?im-nsx)`       | 为表达式后面的部分改变处理选项                               |
| `(?(exp)yes|no)`  | 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no |
| `(?(exp)yes)`     | 同上，只是使用空表达式作为no                                 |
| `(?(name)yes|no)` | 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no |
| `(?(name)yes)`    | 同上，只是使用空表达式作为no                                 |

---

下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。

##### 例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息

```python
"""
验证输入用户名和QQ号是否有效并给出对应的提示信息

要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0
"""
import re

def main():
  username = input('Please Enter the Username: ')
  qq = input('Please Enter the QQ No.: ')
  # match函数的第一个参数是正则表达式字符串或正则表达式对象
  # 第二个参数是要跟正则表达式做匹配的字符串对象
  m1 = re.match(r'^[0-9a-zA-Z]{6,20}$', username)
  if not m1:
    print('Please a valid username.')
  m2 = re.match(r'^[1-9]\d{4,11}$', qq)
  if not m2:
    print('Please enter a valid QQ No.')
  if m1 and m2:
    print('The information is valid.')
    
if __name__  == '__main__':
  main()


```

> **提示：** 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\，例如表示数字的\d得书写成`\\d`，这样不仅写起来不方便，阅读的时候也会很吃力。

##### 例子2：从一段文字中提取出国内手机号码。

下面这张图是截止到2017年底，国内三家运营商推出的手机号段。

![](/Users/zyc/Documents/Notes/fundamentals/assets/tel-start-number-20190913161558902.png)

```python
import re

def main():
  # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字
  pattern = re.compile(r'(?<=\D)1[34578]\d{9}(?=\D)')
  setence = '''
  重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，
  不是15600998765，也是110或119，王大锤的手机号才是15600998765。
  '''
  # 查找所有匹配并保存到一个列表中
  mylist = re.findall(pattern, sentence)
  print(mylist)
  print('------------------')
  # 通过迭代器取出匹配对象并获得匹配的内容
  for temp in pattern.finditer(sentence):
    print(temp.group())
  print('------------------')
  # 通过search函数指定搜索位置找出所有匹配
  m = pattern.search(sentence)
  while m:
    print(m.group())
    m = pattern.search(sentence, m.end())
    
if __name__  == '__main__':
  main()

```

> > **说明：** 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：`(?<=\D)(1[38]\d{9}|14[57]\d{8}|15[0-35-9]\d{8}|17[678]\d{8})(?=\D)`，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。

##### 例子3：替换字符串中的不良内容

```python
import re

def main():
	sentence = 'Are you a retard. Fuck you!'
	purified = re.sub('fuck|shit|retard','*',sentence,flags=re.IGNORECASE)
  print(purified)
  
if __name__  == '__main__':
  main()

```

>  re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用[按位或运算符](http://www.runoob.com/python/python-operators.html#ysf5)进行叠加，如`flags=re.I | re.M`。

##### 例子4：拆分长字符串

```python
import re

def main():
  poem = '窗前明月光，疑是地上霜。举头望明月，低头思故乡。'
  sentence_list = re.split(r'[，。,.]', poem)
  while '' in sentence_list:
    print(sentence_list)
    
if __name__  == '__main__':
  main()
```

